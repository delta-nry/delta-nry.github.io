---
layout: post
title: Is Software Engineering "Real" Engineering?
---

I plan to graduate with a software engineering degree, but I've always had the notion that software engineering doesn't have the credibility that other engineering disciplines have. [Terence Parr](http://parrt.cs.usfca.edu/doc/software-not-engineering.html) argues that software development is not like engineering and that "the term 'software engineering' is more a goal than how we actually write software." Parr does give good arguments describing the difficulty and non-intuitive nature of software engineering, but the arguments made do not necessarily discredit the engineering basis of the field.

Parr argues that unlike physical components, software components do not exist in the real world and are harder to visualize and more unpredictable. Parr also adds that software engineering has more midcourse design changes than "real" engineering fields. However, object-oriented programming exists to facilitate the more intuitive notion of real-world objects to software. Additionally, judicious unit testing can mitigate unpredictability in software. Midcourse design changes are presumably a management problem, and I stress that more people ought to acknowledge that there are limits to software malleability before the integrity of an entire software system breaks. Even though software is harder to spatially and intuitively grasp, it is still akin to physical systems and subject to proper engineering practices.

Software engineering appears to be the process of taking near-infinite (if not completely infinite) complexity and arranging it in a way that is sensible to humans. The vast amount of flawed, overbudget and failed software systems is not necessarily a symptom of incompetence in the field, but certainly is a symptom of managing such vast complexity. With near-absent physical constraints, software engineering is arguably just as, if not more difficult than "real" engineering.

But complexity is not only to blame; integrity is to blame as well. Virtually all of our software comes with no warranty. Most people don't guarantee that their software will work perfectly, and software engineers with integrity should be able to make this guarantee. Software engineers, their work, their responsibilities and their liabilities ought to be treated with the same scrutiny as "real" engineers. Only then will they have no doubt that software engineering has credibility.

EDIT (April 26, 2015): I now believe that instead of trying to map the concepts of real-world objects to software objects, we should instead focus on creating data types with well-defined behaviours and invarients. Whether or not these data types are created in an object-oriented fashion is up to the software designer to determine. I believe that a data type with well-defined behaviours and invarients can approach the predictability of real-world objects.

EDIT (October 20, 2015):

After further thought about this topic, some of my opinions about it have changed. I agree with Terence on the difficulties of software components not existing in the real world and their possibly unpredictable behaviours. However, we can reduce these difficulties by using reliable, well-known software libraries and frameworks, as well as testing small units of data causing as little side effects as possible. It is unfortunate that frequent midcourse design changes can be a burden on many software teams. Although some projects embrace this by using agile methodologies, I believe that midcourse design changes should not be recommended for certain software projects where failure costs are high. We should warn our customers that midcourse design changes could compromise the success of these projects. Despite all of this, I still believe that we can apply engineering principles to software development. Though they may not be as effective as in other engineering disciplines, they can still improve the quality of projects when used effectively.

Although it would be ideal that our software came with warranties, I now believe that in reality, a software product that releases with a few bugs is often better than a bug-free one that comes late or never gets released. It may be impossible or infeasible to create perfect, bug-free software, and engineers must strike a fine balance between when to release software and the amount or severity of the bugs it may contain. This mentality may not be tolerated for certain real-time or life-critical software applications where more is at stake, but fortunately, not all software projects have such requirements. Even though software engineering may or may not be as respected as other engineering disciplines, I now believe that developing perfect, bug-free software will not change this, as even the other engineering fields cannot create perfect projects. Due to the prevalence of software and the fact that the field is relatively young, I am fairly optimistic that software engineering will mature just like the other engineering fields have. In hindsight, I admit that my concerns of software engineering not being as respected as other engineering disciplines may have been mistaken.
